using System;
using System.Collections;
using System.Reflection;
using MbUnit.Core;
using MbUnit.Core.Runs;
using MbUnit.Core.Framework;
using MbUnit.Core.Invokers;
using TestFu.Grammars;

namespace MbUnit.Framework
{
    /// <summary>
    /// Identifies the tagged class as a Production Grammar Fixture
    /// </summary>
    /// <remarks>
    /// For more information on Production Grammar Fixtures, please read this <a href="http://blog.dotnetwiki.org/ProductionGrammarFixtureInMbUnit.aspx">introduction</a>.
    /// </remarks>
    [AttributeUsage(AttributeTargets.Class,AllowMultiple=false,Inherited=true)]	
	public sealed  class GrammarFixtureAttribute : TestFixturePatternAttribute
	{
        /// <summary>
        /// Returns a new instance of a <see cref="ProductionGrammarRun"/> class
        /// </summary>
        /// <returns></returns>
		public override IRun GetRun()
		{
			return new ProductionGrammarRun();
        }

        #region ProductionGrammarRun
        /// <summary>
        /// Represents a run of tests as generated according to the production grammar which provides a test method with data
        /// </summary>
        public class ProductionGrammarRun : Run
        {
            /// <summary>
            /// Populates the <see cref="RunInvokerTree"/> invoker graph
            /// with <see cref="IRunInvoker"/> generated by the run.
            /// </summary>
            /// <param name="tree">Invoker tree</param>
            /// <param name="parent">parent vertex</param>
            /// <param name="t">class type that is marked by the run</param>
            public override void Reflect(RunInvokerTree tree, RunInvokerVertex parent, Type t)
            {
                foreach (MethodInfo grammar in TypeHelper.GetAttributedMethods(t, typeof(GrammarAttribute)))
                {
                    foreach (MethodInfo seed in TypeHelper.GetAttributedMethods(t, typeof(SeedAttribute)))
                    {
                        ProductionGrammarRunInvoker invoker =
                            new ProductionGrammarRunInvoker(this, grammar, seed);
                        tree.AddChild(parent, invoker);
                    }
                }

            }

            /// <summary>
            /// Gets a value indicating whether the run is considered as a test or not.
            /// </summary>
            /// <value>true if the <see cref="ProductionGrammarRun"/> instance is a test</value>
            public override bool IsTest
            {
                get
                {
                    return true;
                }
            }

            /// <summary>
            /// Gets a descriptive name of the <see cref="ProductionGrammarRun"/>
            /// </summary>
            /// <value>A descriptive name of the <see cref="ProductionGrammarRun"/></value>
            public override string Name
            {
                get
                {
                    return this.GetType().Name;
                }
            }

        }
        #endregion    
    
        #region ProductionGrammarRunInvoker

        /// <summary>
        /// A class that knows how to invoke a test using input from a production grammar.
        /// </summary>
        public class ProductionGrammarRunInvoker : RunInvoker
        {
            private MethodInfo grammarMethod;
            private MethodInfo seedMethod;

            /// <summary>
            /// Initializes a new instance of the <see cref="ProductionGrammarRunInvoker"/> class.
            /// </summary>
            /// <param name="generator">The generator.</param>
            /// <param name="grammarMethod">The grammar method.</param>
            /// <param name="seedMethod">The seed method.</param>
            public ProductionGrammarRunInvoker(
                IRun generator,
                MethodInfo grammarMethod,
                MethodInfo seedMethod
                )
			:base(generator)
            {
                if (grammarMethod == null)
                    throw new ArgumentNullException("grammarMethod");
                if (seedMethod == null)
                    throw new ArgumentNullException("seedMethod");
                this.grammarMethod = grammarMethod;
                this.seedMethod = seedMethod;
            }

            /// <summary>
            /// Returns the name of the test based on the seed method and grammar method names.
            /// </summary>
            /// <value>The name.</value>
            public override string Name
            {
                get
                {
                    return String.Format("Grammar({0},{1})",
                        this.grammarMethod.Name,
                        this.seedMethod.Name
                        );
                }
            }

            /// <summary>
            /// Executes the specified test <paramref name="o"/>
            /// </summary>
            /// <param name="o">The test.</param>
            /// <param name="args">The parameters for the test.</param>
            /// <returns>null</returns>
            /// <exception cref="ArgumentException">Thrown if <see cref="grammarMethod"/> does not return an <see cref="IGrammar"/></exception>
            public override object Execute(object o, System.Collections.IList args)
            {
                Object seed = this.seedMethod.Invoke(o, null);
                IGrammar grammar = this.grammarMethod.Invoke(o, null) as IGrammar;
                if (grammar == null)
                    throw new ArgumentException("Grammar method " + this.grammarMethod.Name + " does not return a IGrammar");
                try
                {
                    grammar.Produce(seed);
                }
                catch (ProductionException)
                { }

                return null;
            }
        }
        #endregion
    }
}
